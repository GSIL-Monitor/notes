js是一个单线程：在JS引擎中负责解释和执行javascript代码的线程只有一个。



实际上还存在**其他的线程**：处理Ajax请求的线程，处理DOM事件的线程，定时器线程，文件读写线程。



同步执行：函数在执行之后能够得到预期的结果（返回值）。

例如：

```js
Math.sqrt(2);
console.log('Hi');
```

异步执行：函数在执行完成之后，还不能得到预期的结果，需要将来通过一定的手段才能得到。

例如：

```js
fs.readFile('foo.txt', 'utf8', function(err, data) {
    console.log(data);
});
```

在readFile函数返回时，我们期望的结果并没有完成，而是要等文件全部读取完成之后。



单线程的缺点：因为必须要等它完全执行完才能进行下一步，因此过程中会造成**堵塞**。

多线程的缺点：待写。



**异步操作**

1. 主线程发起请求；
2. 工作线程接收到请求，并告诉主线程已收到请求；
3. 主线程可以继续执行后面的代码，同时工作线程执行异步任务；
4. 工作线程完成工作后，通知主线程；
5. 主线程接收到通知后，处理工作线程传回来的数据（调用回调函数）；



异步函数的模型形式：

<span style="color:red;">A（args...，callbackFn）</span>

这也可以称为异步操作的发起函数：发起函数叫A，回调函数叫callbackFn。

但是这样也不绝对，比如setTimeout的格式就是回调函数在前，参数在后：

<span style="color:red;">setTimeout（fn，1000）</span>

甚至还有分开的情况，比如Ajax将发起函数和对调函数分开：

```js
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = xxx; // 添加回调函数
xhr.open('GET', url);
xhr.send(); // 发起函数
```



#### 消息队列和事件循环

异步操作在完成之后需要通知主线程，这里我们需要了解一下这个**通知机制**

> 工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。

**消息队列**：消息队列是一个先进先出的队列，它里面存放各种消息。

**事件循环**：事件循环是指主线程重复从消息队列中取消息、执行的过程。

**主线程的职责**：从消息队列取消息，执行该消息，取消息，执行该消息，取消息，执行该消息。。。。(主线程的最大容量就只有一个消息)。

**消息**：注册异步任务时添加的回调函数callbackFn（A（args...，callbackFn））。

**通知**：工作线程对主线程的通知，就是执行回调函数。

**事件循环**：消息队列中的每一条消息都对应着一个事件，所以称其为事件队列

**DOM事件也是异步操作**：当用户通过一定的操作之后，触发了事件，同时监听函数被调用。从异步的过程看，addEventListener函数就是一个异步操作的发起函数，事件监听器函数就是异步操作的回调函数。

<span style="color:red">事件机制实际就是异步过程的通知机制。所有的异步过程也可以用事件来描述。</span>



### 异步编程

#### 一阶段：回调函数









缺点：会造成回调地狱的情况，代码阅读嵌套过多，极其复杂。

#### 二阶段：promise

使用promise语法，实现**异步代码同步写法**。

优点：链式写法，解决了回调函数处理多重一步嵌套带来的回调地狱问题，使代码更加利于阅读；

缺点：本质依然是使用回调函数实现异步功能，没有太大变化。

#### 三阶段：generator



#### 四阶段：Async/await



























































