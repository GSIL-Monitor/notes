## 提出问题

- 数据库中存储金额的部分是以分为单位，但是前端展示的是元，因此前端需要将元转化为分。但是在这个转化过程 `1.11*100=111` 出现了 `JS` 特有的误差问题： `1.11*100=111.00000000000001`  



## 分析问题

其实这种情况是由于JS本身对数字计算的处理的问题，其他也有类似的情况：

```js
0.1+0.2 = 0.30000000000000004   //加法
0.27-0.11 = 0.16000000000000003 //减法
19.9*100 = 1989.9999999999998   //乘法
0.3/0.1 = 2.9999999999999996    //除法
```



## 原理解析

首先最根本的原因在于JS的数据类型的开放性，相比于其他语言的数据类型的`int-double-float`  在JS中所有的数据都是Number类型

双精度浮点数：double（64位）

他可以表示十进制的15或16位有效数字，表示数字的绝对值范围是：

`[2.23*10^(-308),1.79*10^308]`。

细心地人可以发现，如果是64位的二进制数，其可以表示的十进制数绝对高于15或16位，这是因为64位的双精度数据结构只用了一部分来表示数字，具体划分为：

> sign bit（符号位）：0表示正数，1表示负数
>
> exponent（指数）：中间的11位用来代表次方数
>
> mantissa（尾数）：后面的52位用来表示精确度

![](E:\WebStorm_Dir\Day_by_Day\Images\64位数字结构.png)

根据上面的结构以及我们使用二进制计算的方法，可以得出一个公式：

![](E:\WebStorm_Dir\Day_by_Day\Images\64位数据结构公式.png)

第一部分：表示该数的正负情况；

第二部分：表示该数的次方情况，大于0则为整数，小于0则为小数；

第三部分：表示一个固定的数字；

表示次方的部分有11位，所以最大能表示2047，但是他需要包含正数和负数，所以：

0x3ff = 1023(中间数)

exponent = 0~1022表示为负（次方为负：小数）

exponent = 1023~2047表示为正（次方为正：整数）

所以我们对次方的运算方式一般使用为：2^（exponent-1023）

## 实例展示

所以数字1的表现形式为：

0—00111111111—0*51—1

00111111111=1023

用上数的公式表示就是：(-1)^0 x 2^(1023-1023) x 1.0=1.0

而0.5的表现形式是“

0—00111111110—0*51—1

表示为(-1)^0x2^(1022-1023)x1.0=0.5



将1.11转化为二进制是这样的：`1.0001110000101000111101011100001010001111010111000011...`

由上面的二进制化可以看出1.11运算出现误差的原因就在于十进制小数转二进制数的时候可能会导致的循环问题，因此我们对齐进行运算之后得到的二进制数也是无限循环的（不会超过52位，超过舍弃），再将这个二进制数转化为10进制数的时候就会出现我们之前所看到的`1.11*100=111.00000000000001`

## 解决问题

常见对这种JS的误差处理的办法是使用相关的JS库，其中较成熟的方案就是：

> - Math.js
>
> - decimal.js

直接引用这两个库就不用考虑会带来的误差问题了。



