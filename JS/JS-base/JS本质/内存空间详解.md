![](E:\WebStorm_Dir\articles\images\内存.png)

### 前言

要理解内存空间中的原理，我们需要对三种数据结构有一个直观的认知：<span style="color:red">栈，堆，队列</span>。

因为这些内存空间的知识涉及到前端方面的：**引用数据类型，引用传递，浅复制，深复制，闭包，原型**等等。

### 数据类型

#### 基本数据类型

基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问。

**基本数据类型**：String，Boolean，Number，undefined，null，Symbol

#### 引用数据类型

引用类型是保存在堆内存中的对象（在JavaScript中数组也是一个对象），值大小不固定，栈内存中存放着**该对象的访问地址**，这个**地址**指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用。

**引用数据类型**：Object，Function，Array，RegExp

### 栈数据结构

与c/c++不同，Javascript中并没有严格意义上区分栈内存与堆内存的概念。因此我们可以理解为javascript的所有数据都是保存在堆内存中的。但是我们在某些场景下，需要将堆内存中的数据以特定数据结构（堆-栈）的思维来实现一些功能，比如javascript的执行上下文。执行上下文的执行顺序就借用了**栈数据结构**的存取方式。（也就是我们后续经常提到的函数调用栈）。

栈的结构其实就是类似于一个乒乓球盒的样子，如图可见：

![](E:\WebStorm_Dir\articles\images\栈.png)

这种数据结构的特点可以归纳成一句话：<span style="color:red">先进后出，后进先出</span>

### 堆数据结构

堆数据结构是一种树状结构。他的存取数据方式与书架上放书的行为类似。书（数据）虽然整齐的放在书架（内存）上，但是每本书都有一个名字（键），我们可以通过书名（键）来找到对应的那本书（值）。好比json格式的数据，数据都是存储在一个键值对（key-value）中，每一个**对**都是独立的，与其他的**对**没有任何关系，所以可以是无序的，因为顺序也是一种关系（比如，我在你前面，你在我后面，都是一种关系），因此在堆数据结构中，我们只需要知道书名（key）就可以了。



### 队列数据结构

在javascript中，理解队列对理解javascript的事件循环机制的原理是十分有帮助的。

队里是一种先进先出的数据结构。下图可以清楚地理解队列的原理：

![](E:\WebStorm_Dir\articles\images\队列.png)

### 变量对象与基础数据类型

JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。

> 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍需要将其区分为**栈-堆**的结构





### 引用数据类型与堆内存

与其他语言不同，JS的引用数据类型的值大小是不固定的，如数组Array。**引用数据类型的值是保存在堆内存中的对象**，JS**不允许直接访问堆内存中的位置**，因此我们**不能直接操作对象的堆内存空间**。

在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存中的实际值相关联。

```js
var a1 = 0;   // 变量对象
var a2 = 'this is string'; // 变量对象
var a3 = null; // 变量对象

var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中
```

![](E:\WebStorm_Dir\articles\images\引用数据类型.png)

因此当我们要范根堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用或地址指针（上面的具体值），然后再从堆内存中取得我们需要的数据。

理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。



### 验证

```js
var a=20;
var b=a;
b=30;
console.log(a);// a=？
```

a  =  20

b  =   ~

~  =  a

b  =  20

b  -> 30

a  =  20

![](E:\WebStorm_Dir\articles\images\变量对象中数据变化.png)

**变量对象中的数据发生变化**

在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。`var b=a`执行之后，a与b虽然值都等于20，但是他们现在已经是互相独立的值了，因此修改b之后a不会有任何变化。

------

```js
// demo02.js
var m = { a: 10, b: 20 }
var n = m;
n.a = 15;
// 这时m.a的值是多少
```

m  =   {a:10,b:20},

n   =   m   ={a:10,b:20}

n.a=15     =>      n=m={a:15,b:20}

m.a===15

**引用类型数据发生变化**

首先，执行引用类型数据的赋值操作时，引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量中，但是不同的是，这个新的值，仅仅只是引用类型的一个地址指针（把m获取数据的地址0x0021ff7d告诉n，n也可以用这个地址0x0021ff7d去获取数据）。当地址指针相同时，尽管它们相互独立，但是在变量中访问到的具体对象实际上是同一个。

![](E:\WebStorm_Dir\articles\images\引用数据类型数据.png)

### 内存空间管理

JavaScript具有自动垃圾回收机制，内存的分配与回收都完全实现了自动管理，但是了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。

JavaScript的内存生命周期：

1. 分配内存
2. 使用分配给你的内存（读，写操作）
3. 不再需要使用的时候释放内存

```js
var a = 20;  // 在内存中给数值变量分配空间
alert(a + 100);  // 使用内存
a = null; // 使用完毕之后，释放内存空间
```

JavaScript在定义变量时就完成了内存分配。

第三步释放内存空间则是我们需要重点理解的一个点。

JavaScript的自动垃圾回收机制就是将不使用的值释放内存，释放内存的方式就是让其指向Null。（这个就是**标记清除**法的本质原理）。不过**标记清除**仅仅找到哪些对象是不再继续使用的，在下一次垃圾回收时释放。

> - 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。
> - 要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节



### 栈内存与堆内存

| 栈内存                 | 堆内存                                       |
| ---------------------- | -------------------------------------------- |
| 存储基础数据类型       | 存储引用数据类型                             |
| 按值访问               | 按引用访问                                   |
| 存储的值大小固定       | 存储的值大小不定，可以动态调整（如数组长度） |
| 由系统自动分配内存空间 | 由代码指定制定分配                           |
| 空间小，运行效率高     | 空间大，运行效率低                           |
| 先进先出，后进后出     | 无序存储，可根据引用直接获取                 |

变量在栈内存中保存的数据实际上是指向堆内存中保存的对象的指针。













引用自：

https://segmentfault.com/a/1190000012646195