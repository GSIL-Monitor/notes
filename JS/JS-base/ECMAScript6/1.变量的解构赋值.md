### 一、什么是解构赋值？

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。解构赋值必须符合下面三条规则：

- 左右结构必须一样
- 右边必须是一个合法的数据
- 声明和赋值必须一句话完成，不能把声明与赋值分开



### 二、数组的解构赋值

```javascript
//普通数组解构
let [a,b,c]=[1,2,3];

//嵌套数组解构
let [foo,[[bar],baz]]=[1,[[2],3]];

//富余数组解构
let [,,third]=["foo","bar","baz"];// thrid=baz
let [head,...tail]=[1,2,3,4];//head=1,tail=[2,3,4]
let [x,y,...z]=["a"];//x=a,y=undefined,z=[]

//不完全解构,即等号左边的模式，只匹配一部分的等号右边的数组
let [x, y] = [1, 2, 3];//x=1,y=2
let [a, [b], d] = [1, [2, 3], 4];//a=1,b=2,d=4
```

通过上述的讲解，可以总结出解构赋值必须左边与右边的模式相同，否则会获得undefined或者直接报错。

```javascript
// 解构赋值允许指定默认值。
let [foo=true]=[];//可以赋值，同时没有赋值时默认为true
let [x,y='b']=['a'];//x=a,y=b
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
let [x = 1] = [null];

// 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
function f() {
    console.log('aaa');
}
let [x = f()] = [1];//不会输出aaa，因为它将1赋值给了x,不会触发f()方法了
let [x = f()] = [];//x没有对应的赋值，就会等于f()，此时调用f()输出aaa

// 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
```

由上面的代码可以看出，只要在满足两边模式相同的情况下，可以设置默认值。

```javascript
// 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
function f() {
    console.log('aaa');
}
let [x = f()] = [1];//不会输出aaa，因为没有使用到
let [x = f()] = [];//输出aaa
```